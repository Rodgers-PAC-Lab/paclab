## This is for functions for dealing with SLEAP data

import tables
import pandas
import matplotlib.pyplot as plt
import my.plot

def load_tracked_sleap_data(hdf5_filename):
    """Load tracks and scores from sleap HDF5 file
    
    This loads the data from the HDF5 file and converts it to a more
    convenient DataFrame.
    
    hdf5_filename : string
        The hdf5 file generated by sleap
        To make this file, run sleap-convert --format analysis on the
        predictions file.
    
    Returns: dict, with the following items
        'tracks_df': DataFrame
            The location of each body part ("node")
            index: frame number
            columns: MultiIndex
                node ('snout', etc)
                coord ('x' or 'y')
            values: The pixel location of each node on each frame, or np.nan
                where no node was found
        
        'scores_df': DataFrame
            The confidence score for each tracked node on each frame
            index: frame number
            columns: node ('snout', etc)
            values: The confidence score
        
        'edge_names': list of lists
            Each sub-list is a list of two node names, e.g. 
            ['mid_back', 'tail_base'], indicating two connected nodes.
    """
    with tables.open_file(hdf5_filename) as fi:
        # Node and edge names
        node_names = fi.root['node_names'][:]
        edge_names = fi.root['edge_names'][:]
        
        # Edges expressed as indices into node_names, instead of by node_name
        edge_inds = fi.root['edge_inds'][:]
        
        # Confidence of each keypoint
        point_scores = fi.root['point_scores'][:].T
        
        # "Tracking" scores, this is all zero for single-animal tracking
        tracking_scores = fi.root['tracking_scores'][:].T
        
        # The actual position of each keypoint on every frame
        # (n_frames, n_nodes, 2, 1)
        tracks = fi.root['tracks'][:].T

    # Decode bytes into stringss
    def decode_a_list(lst):
        return [x.decode('utf-8') for x in lst]
    node_names = decode_a_list(node_names)
    edge_names = [decode_a_list(edge) for edge in edge_names]


    ## Reshape the data
    # Slice out the last axis (subject number in frame, only one per frame for now)
    tracks = tracks[:, :, :, 0]
    tracking_scores = tracking_scores[:, 0]
    point_scores = point_scores[:, :, 0]

    # Reshape tracks from (n_frames, n_keypoints, 2) into (n_frames, n_keypoints * 2)
    tracks2 = tracks.reshape((len(tracks), -1))


    ## Convert array to DataFrame so we can label it more usefully
    # Convert to dataframe
    tracks_df = pandas.DataFrame(tracks2)

    # Because we have reshaped into (n_frames, n_keypoints * 2), we can
    # label the columns as a MultiIndex of node and coordinate
    tracks_df.columns = pandas.MultiIndex.from_product([
        pandas.Index(node_names, name='node'), 
        pandas.Index(['x', 'y'], name='coord')
        ])

    # The index is frame number
    tracks_df.index.name = 'frame'

    # Also convert the confidence scores into a DataFrame (n_frames, n_nodes)
    scores_df = pandas.DataFrame(point_scores)
    scores_df.index.name = 'frame'
    scores_df.columns = pandas.Index(node_names, name='node')    
    
    
    ## Return
    return {
        'tracks_df': tracks_df,
        'scores_df': scores_df,
        'edge_names': edge_names,
        }

def plot_example_frame(
    frame, 
    frame_tracks=None, 
    xlims=None, 
    ylims=None, 
    dpi=100, 
    edge_names=None, 
    octagon_keypoints=None,
    ):
    """Plot example frame with overlaid tracks, filling the plt window
    
    frame : 2d numpy array
        The image to plot
    frame_tracks : DataFrame or None
        If not None, this should contain keypoints on the mouse, with
        columns 'x' and 'y'
    xlims : 'from_octagon', tuple, or None
        If tuple, the image is cropped to these xlims
        If 'from_octagon' and octagon_keypoints is not None, the xlims
        are taken from the west and east ports
        If None, no cropping
    ylims : similar to xlims
    dpi : float
        The figsize of the figure is the range defined by xlims and ylims,
        divided by this value. Higher values simply make the figure smaller,
        not more detailed
    edge_names : None or list of list of paired nodes
        If None, a default matching our current SLEAP model is used
    octagon_keypoints : None or DataFrame
        If not None, the edges and ports of the octagon are plotted
        It should have 'x' and 'y' on the columns
    
    Returns : plt.Figure
    """
    # Default edge_names
    if edge_names is None:
        if 'R thigh' in frame_tracks.index:
            # Old syntax
            edge_names = [
                ['mid_back', 'tail_base'],
                ['snout', 'mid_ears'],
                ['mid_ears', 'mid_back'],
                ['L ear', 'mid_ears'],
                ['R ear ', 'mid_ears'],
                ['L ear', 'snout'],
                ['R ear ', 'snout'],
                ['L forelimb', 'L thigh'],
                ['R forelimb', 'R thigh'],
                ['L thigh', 'tail_base'],
                ['R thigh', 'tail_base'],
                ['L forelimb', 'mid_ears'],
                ['R forelimb', 'mid_ears'],
                ['L thigh', 'mid_back'],
                ['R thigh', 'mid_back'],
                ['R forelimb', 'mid_back'],
                ['L forelimb', 'mid_back'],
                ['tail_base', 'tail_1'],
                ['tail_3', 'tail_end'],
                ['tail_1', 'tail_mid'],
                ['tail_mid', 'tail_3'],
                ]
        else:
            # New names
            edge_names = [
                ['mid_back', 'tail_0'],
                ['snout', 'mid_ears'],
                ['mid_ears', 'mid_back'],
                ['L ear', 'mid_ears'],
                ['R ear', 'mid_ears'],
                ['L ear', 'snout'],
                ['R ear', 'snout'],
                ['L forelimb', 'L hindlimb'],
                ['R forelimb', 'R hindlimb'],
                ['L hindlimb', 'tail_0'],
                ['R hindlimb', 'tail_0'],
                ['L forelimb', 'mid_ears'],
                ['R forelimb', 'mid_ears'],
                ['L hindlimb', 'mid_back'],
                ['R hindlimb', 'mid_back'],
                ['R forelimb', 'mid_back'],
                ['L forelimb', 'mid_back'],
                ['tail_0', 'tail_1'],
                ['tail_3', 'tail_4'],
                ['tail_1', 'tail_2'],
                ['tail_2', 'tail_3'],
                ]            
        
    # Default lims
    if xlims is None:
        xlims = (0, frame.shape[1])
    elif xlims == 'from_octagon' and octagon_keypoints is not None:
        xlims = (
            octagon_keypoints.loc['W', 'x'] - 10,
            octagon_keypoints.loc['E', 'x'] + 10,
            )            
    
    if ylims is None:
        ylims = (0, frame.shape[0])
    elif ylims == 'from_octagon' and octagon_keypoints is not None:
        # The ypos of S is greater than that of N
        ylims = (
            octagon_keypoints.loc['N', 'y'] - 10,
            octagon_keypoints.loc['S', 'y'] + 10,
            )

    # Convert lims to shape
    xwidth = xlims[1] - xlims[0]
    ywidth = ylims[1] - ylims[0]        
    
    # Plot
    f, ax = plt.subplots(figsize=(xwidth/dpi, ywidth/dpi))
    f.subplots_adjust(left=0, right=1, bottom=0, top=1)
    
    # Plot image
    im = my.plot.imshow(frame, cmap=plt.cm.gray, ax=ax)
    im.set_clim((0, 255))
    
    # Plot tracks
    if frame_tracks is not None:
        ax.plot(frame_tracks['x'], frame_tracks['y'], marker='o', color='green', mfc='none', ms=4, ls='none')

        # Plot edges
        for edge in edge_names:
            # Get the keypoints for this individual edge
            edge_keypoints = frame_tracks.loc[edge]
            
            # Plot them
            ax.plot(edge_keypoints['x'], edge_keypoints['y'], '-', color='green')

    # Plot octagon
    outer = ['NNEO', 'ENEO', 'ESEO', 'SSEO', 'SSWO', 'WSWO', 'WNWO', 'NNWO']
    inner = ['NNEI', 'ENEI', 'ESEI', 'SSEI', 'SSWI', 'WSWI', 'WNWI', 'NNWI']
    ports = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']

    # Plot octagon
    if octagon_keypoints is not None:
        for n in range(len(outer)):
            corner0 = outer[n]
            if n == len(outer) - 1:
                corner1 = outer[0]
            else:
                corner1 = outer[n + 1]

            # Connect the outers
            topl = octagon_keypoints.loc[[corner0, corner1], ['x', 'y']].values
            ax.plot(topl[:, 0], topl[:, 1], 'k-', lw=.75)
            
            # Connect outer to inner
            inner_corner = inner[n]
            topl = octagon_keypoints.loc[[corner0, inner_corner], ['x', 'y']].values
            ax.plot(topl[:, 0], topl[:, 1], 'k-', lw=.75)
            
            # Plot port
            port_loc = octagon_keypoints.loc[ports[n], ['x', 'y']].values
            ax.plot([port_loc[0]], [port_loc[1]], color='gray', marker='s')    

    # Apply the crop and invert the ylims (image-like)
    ax.set_xlim(xlims)
    ax.set_ylim(ylims[::-1])
    
    # Remove frame
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_frame_on(False)
    
    # Return
    return f