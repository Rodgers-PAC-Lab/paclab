## This is for functions for dealing withi SLEAP data

import tables
import pandas

def load_tracked_sleap_data(hdf5_filename):
    """Load tracks and scores from sleap HDF5 file
    
    This loads the data from the HDF5 file and converts it to a more
    convenient DataFrame.
    
    hdf5_filename : string
        The hdf5 file generated by sleap
        To make this file, run sleap-convert --format analysis on the
        predictions file.
    
    Returns: dict, with the following items
        'tracks_df': DataFrame
            The location of each body part ("node")
            index: frame number
            columns: MultiIndex
                node ('snout', etc)
                coord ('x' or 'y')
            values: The pixel location of each node on each frame, or np.nan
                where no node was found
        
        'scores_df': DataFrame
            The confidence score for each tracked node on each frame
            index: frame number
            columns: node ('snout', etc)
            values: The confidence score
        
        'edge_names': list of lists
            Each sub-list is a list of two node names, e.g. 
            ['mid_back', 'tail_base'], indicating two connected nodes.
    """
    with tables.open_file(hdf5_filename) as fi:
        # Node and edge names
        node_names = fi.root['node_names'][:]
        edge_names = fi.root['edge_names'][:]
        
        # Edges expressed as indices into node_names, instead of by node_name
        edge_inds = fi.root['edge_inds'][:]
        
        # Confidence of each keypoint
        point_scores = fi.root['point_scores'][:].T
        
        # "Tracking" scores, this is all zero for single-animal tracking
        tracking_scores = fi.root['tracking_scores'][:].T
        
        # The actual position of each keypoint on every frame
        # (n_frames, n_nodes, 2, 1)
        tracks = fi.root['tracks'][:].T

    # Decode bytes into stringss
    def decode_a_list(lst):
        return [x.decode('utf-8') for x in lst]
    node_names = decode_a_list(node_names)
    edge_names = [decode_a_list(edge) for edge in edge_names]


    ## Reshape the data
    # Slice out the last axis (subject number in frame, only one per frame for now)
    tracks = tracks[:, :, :, 0]
    tracking_scores = tracking_scores[:, 0]
    point_scores = point_scores[:, :, 0]

    # Reshape tracks from (n_frames, n_keypoints, 2) into (n_frames, n_keypoints * 2)
    tracks2 = tracks.reshape((len(tracks), -1))


    ## Convert array to DataFrame so we can label it more usefully
    # Convert to dataframe
    tracks_df = pandas.DataFrame(tracks2)

    # Because we have reshaped into (n_frames, n_keypoints * 2), we can
    # label the columns as a MultiIndex of node and coordinate
    tracks_df.columns = pandas.MultiIndex.from_product([
        pandas.Index(node_names, name='node'), 
        pandas.Index(['x', 'y'], name='coord')
        ])

    # The index is frame number
    tracks_df.index.name = 'frame'

    # Also convert the confidence scores into a DataFrame (n_frames, n_nodes)
    scores_df = pandas.DataFrame(point_scores)
    scores_df.index.name = 'frame'
    scores_df.columns = pandas.Index(node_names, name='node')    
    
    
    ## Return
    return {
        'tracks_df': tracks_df,
        'scores_df': scores_df,
        'edge_names': edge_names,
        }